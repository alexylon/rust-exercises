;1	08.12.2016 13:38:33	jlawrie2	
X0 72a063c 0 729a370 0 0 0 0

X0 729a370 72a063c 72a1c68 72a2568 0 0 0
-- All Test Cases - GeneralFunctions--
X0 72a1c68 729a370 72a1ce8 72a1e68 0 0 0
-- Rounding Functions --
X1 72a1ce8 72a1c68 0 72a1d68 0 0 2
GEN Ceil(n; d)
'GEN Ceil'(123.4562; 3)
123.457
X1 72a1d68 72a1c68 0 72a1de8 0 0 2
GEN Round(n; d)
'GEN Round'(123.4567; 3)
123.457
X1 72a1de8 72a1c68 0 0 0 0 2
GEN Floor(n; d)
'GEN Floor'(123.4567; 2)
123.45
X0 72a1e68 729a370 72a1ee8 72a2268 0 0 0
-- String Handling Functions --
X1 72a1ee8 72a1e68 72a1f68 72a1fe8 0 0 2
GEN Last Character Position
'GEN Last Character Position'("SINGING"; "N")
6
X1 72a1f68 72a1ee8 0 0 0 0 2
GEN Last Character Position Rec
'GEN Last Character Position Rec'("SingING"; "n"; 0)
3
X1 72a1fe8 72a1e68 0 72a2068 0 0 2
GEN Instr("1000500022";"1000")
'GEN Instr'("1000500022";"1000")
1
X1 72a2068 72a1e68 72a20e8 72a2168 0 0 2
GEN Is Value Null
'GEN Is Value Null'("")
1
X1 72a20e8 72a2068 0 0 0 0 2
GEN Is Value Null
'GEN Is Value Null'(" ")
0
X1 72a2168 72a1e68 0 72a21e8 0 0 2
GEN Test Delimited String To Vector- "1,2,3"
'GEN Test Delimited String To Vector'("1,2,3"; ",")
1,2,3
X1 72a21e8 72a1e68 0 0 0 0 2
GEN Test Delimited String To Vector- "3"
'GEN Test Delimited String To Vector'("3"; ",")
3
X0 72a2268 729a370 72a22e8 72a2468 0 0 0
-- MM Version Info --
X1 72a22e8 72a2268 72a2368 0 0 0 2
GEN Version
'GEN Version'
ModelName=1çä2çä3çä4çä5çä6çä7çä8çä9çä çäRepositoryçä çäisDirtyçä çäRevisionçä çäTagçä çäTimeçä çämoduleTagçä çäIsModuleDirtyçä çäParent
X1 72a2368 72a22e8 0 72a23e8 0 0 2
GEN Versions(i;tabrow)
'GEN Versions'(3;5)
isDirtyçä çäRevisionçä çäTag
X1 72a23e8 72a22e8 0 0 0 0 2
GEN nl
'GEN nl'
çä
X1 72a2468 729a370 0 72a24e8 0 0 2
GEN Interpolate
'GEN Interpolate'(1000; 2000; 3; 12)
1250
X1 72a24e8 729a370 0 0 0 0 2
GEN VersionInfo
'GEN VersionInfo'
Parent - Parent
X1 72a2568 72a063c 0 72a25e8 0 0 2
GEN OrderedReleaseAmt(releaseAmount; bucketIndex; bucketValueVector; releaseType)
'GEN OrderedReleaseAmt'(500; 1; "(58.82!88.8!64.33)"; 0)
0
X3 72a25e8 72a063c 0 72a2668 0 0 2
GEN String Vector Add
GEN String Vector add("(1!2!3)"; "(4!5!6)")
9
INPUT String Vector 1
4
INPUT String Vector 2
5
X3 72a2668 72a063c 0 72a26e8 0 0 2
GEN String Vector Subtract
GEN String Vector Subtract("(4!5!6)"; "(1!2!3)")
-1
INPUT String Vector 1
4
INPUT String Vector 2
5
X3 72a26e8 72a063c 0 72a2768 0 0 2
GEN String Vector Subtract
Gen String Vector Subtract("(4!5!6)";"(1!2!3)")
-2
INPUT String Vector 1
2
INPUT String Vector 2
4
X3 72a2768 72a063c 0 72a27e8 0 0 2
GEN String Vector Add
GEN String Vector Add("(1!2!3)";"(4!5!6)")
5
INPUT String Vector 1
3
INPUT String Vector 2
2
X1 72a27e8 72a063c 0 72a2868 0 0 2
GEN Vector Unique Elements(useVector; position; string; vCounter; counter)
GEN Vector Unique Elements("((X!Y!Z)!(X!Y!Z)!(X!Y!Z)!(XX!Y!Z)!(XX!Y!Z)!(XX!Y!Z))"; 0; ""; 0; 0)

X1 72a2868 72a063c 0 0 0 0 2
GEN Vector of Vectors String Conversion(useVector; delimiter1; delimiter2)
GEN Vector of Vectors String Conversion(V_(V_("1element");V_(1;2;3);V_("A";"B")); ";"; "#")
1element#1;2;3#A;B
O0 72a04d4 0 0 0 0 0 0

E0 72a054c 0 0 0 0 0 0

L0 72a05c4 0 0 0 0 0 0

B0 72a07a4 0 0 0 0 0 0

P3 72a06b4 0 72a28e8 0 0 0 2

--description
Common sub-model containing common general functions used throughout the models.çä çäRounding, string handling, and model manager version information are some of the items contained here.çä çäRELEASE LOG:çäRELEASE 1501 - PAC031 MEC AvoidanceçäRELEASE 1301 - wmA-J DevelopmentçäRELEASE 1101 - PAC013 calcTypeçäRELEASE 1101 - PAC018 IRR
LICENSENAME
"CSC US internal use only - Workbench"
COMPILERVERSION
"5.3.1"
P13 72a28e8 72a06b4 72a2968 0 0 0 2
Common General Functions Model
IncType
mandatory
IncRule

IncValue

OUTPUT Comment
"Model:   GeneralFunctions model.çä Author:  John Heumannçä Date:     10/31/2007 çä Modification Log:çä Date              Modeler               Change Descriptionçä 10/31/2007     John Heumann     Created model.çä"
OUTPUT Runtime Version
"1.0.0"
OUTPUT Runtime Date
"04/22/2016"
OUTPUT Source Version File
"GeneralFunctions.pms"
OUTPUT Source Version Computer
"VPMS_SERVER"
OUTPUT Source Version Number
'GEN VersionInfo'
OUTPUT Source Version Date
"04/22/2016"
OUTPUT Source Version Author
"CSC"
OUTPUT Source Version Comment
"PA1603 Delivery"
OUTPUT Audit History Block
"04/22/2016 PA1601 Delivery"
P3 72a2968 72a28e8 0 0 0 0 2
All Products
IncType
mandatory
IncRule

IncValue

F0 72a072c 0 72a29e8 0 0 0 0

F1 72a29e8 72a072c 72a2a68 72b1228 0 0 2
:GEN
Funktion

F1 72a2a68 72a29e8 72a2ae8 72a4588 0 0 2
-- Rounding Functions --
Funktion

F1 72a2ae8 72a2a68 0 72a2b68 0 0 2
GEN Ceil(n; d)
Funktion
CEIL(n * 10 ^ d & "") / 10 ^ d
F1 72a2b68 72a2a68 0 72a4508 0 0 2
GEN Floor(n; d)
Funktion
FLOOR(n * 10 ^ d & "") / 10 ^ d
F1 72a4508 72a2a68 0 34ab40a4 0 0 2
GEN Round(n; d)
Funktion
IF (d >= 15 ; çä  n ; çä  IF (V_LENGTH(n) = 0 ; çä    ROUND(n * 10 ^ d & "") / 10 ^ d ; çä    VECTORX(ele;0;V_LENGTH(n) - 1;ROUND(E_(n;#ele) * 10 ^ d & "") / 10 ^ d)çä  )çä)
F1 34ab40a4 72a2a68 0 0 0 0 2
GEN WMAJ Unit Round
Funktion
4
F1 72a4588 72a29e8 72a4608 72a4c88 0 0 2
-- String Handling Functions --
Funktion

F1 72a4608 72a4588 0 72a4688 0 0 2
GEN Conditional Convert(value; if_value; then_value)
Funktion
IF (value ALIKE if_value ; çä  then_value ; çä  valueçä)
F1 72a4688 72a4588 72a4708 72a4788 0 0 2
GEN Instr(str;subs)
Funktion
'GEN Instr Rec'(str;subs;V_LENGTH(subs)) > 0
F1 72a4708 72a4688 0 0 0 0 2
GEN Instr Rec(str; subs; i)
Funktion
IF ( /*starting point, found match*/ i = 1 || INSTR(str;subs) > 0 ; çä   /*replace match*/ INSTR(str;subs) ; çä   /*Look for next match*/ 'GEN Instr Rec'(str;v_rest(subs);i - 1) + INSTR(str;subs)çä)
F1 72a4788 72a4588 0 72a4808 0 0 2
GEN Is Value Null(value)
Funktion
STRCMP(value;"") = 0 //IF(STRCMP(value; "")=0;çä//â1;â// return 1 if value  =  NULLçä//â0â// return 0 if value <> NULLçä//)ä
F1 72a4808 72a4588 72a4888 72a4908 0 0 2
GEN Last Character Position(str; character)
Funktion
IF ( /*Found match?*/ INSTR(str;character) = 0 ; çä   /*No*/ 0 ; çä   /*Yes - return last char position*/ 'GEN Last Character Position Rec'(RIGHT(str;LENGTH(str) - INSTR(str;character));character;INSTR(str;character))çä)
F1 72a4888 72a4808 0 0 0 0 2
GEN Last Character Position Rec(str; character; pos)
Funktion
IF ( /*Found match?*/ INSTR(str;character) = 0 ; çä   /*No - use previous position*/ pos ; çä   /*Yes - try again*/ 'GEN Last Character Position Rec'(RIGHT(str;LENGTH(str) - INSTR(str;character));character;pos + INSTR(str;character))çä)
F1 72a4908 72a4588 72a4988 72a4a88 0 0 2
GEN String In Vector(s; v)
Funktion
NOT('GEN Where is String in VECTOR'(v;s) = -1)
F1 72a4988 72a4908 72a4a08 0 0 0 2
GEN Where is String in VECTOR(v;s)
Funktion
'Vector Search'(v;s;0)
F1 72a4a08 72a4988 0 0 0 0 2
Vector Search(v;s;i)
Funktion
IF (i >= V_LENGTH(v) ; çä  -1 ; çä  IF (E_(v;i) ALIKE s ; çä    V_STRINGX(i) ; çä    IF (V_LENGTH(E_(v;i)) > 1 ; çä      'Vector Search'(E_(v;i);s;V_INSERT(i;0;0)) ; çä      'Vector Search'(v;s;V_REPLACE(i;i + 1;0))çä    )çä)çä)
F1 72a4a88 72a4588 72a4b08 0 0 0 2
Vector GEN Delimited String To Vector(s; delimiter)
Funktion
IF ( /*No match?*/ INSTR(s;delimiter) = 0 ; çä   /*Return vector as is - only one field*/ V_(s) ; çä   // Elseçä'V GEN Build Vector From Delimited String'(s;delimiter)çä)
F1 72a4b08 72a4a88 72a4b88 72a4c08 0 0 2
V GEN Build Vector From Delimited String(s; delimiter)
Funktion
V_CONCAT(V_(LEFT(s;INSTR(s;delimiter) - 1));IF ( /*If delimiter is found*/ INSTR(RIGHT(s;LENGTH(s) - INSTR(s;delimiter));delimiter) > 0 ; çä   /*chop into smaller pieces*/ 'Vector GEN Delimited String To Vector Rec'(RIGHT(s;LENGTH(s) - INSTR(s;delimiter));delimiter) ; çä   // ElseçäRIGHT(s;LENGTH(s) - INSTR(s;delimiter))çä))
F1 72a4b88 72a4b08 0 0 0 0 2
Vector GEN Delimited String To Vector Rec(s; delimiter)
Funktion
IF ( /*Found delimiter?*/ INSTR(s;delimiter) > 0 ; çä   /*Add piece to vector*/ V_CONCAT(V_(LEFT(s;INSTR(s;delimiter) - 1));IF ( /*If delimiter in string*/ INSTR(RIGHT(s;LENGTH(s) - INSTR(s;delimiter));delimiter) ; çä     /*cohp into smaller pieces*/ 'Vector GEN Delimited String To Vector Rec'(RIGHT(s;LENGTH(s) - INSTR(s;delimiter));delimiter) ; çä     // ElseçäRIGHT(s;LENGTH(s) - INSTR(s;delimiter))çä  )) ; çä // Elseçä""çä)
F1 72a4c08 72a4a88 0 0 0 0 2
GEN Test Delimited String To Vector(s; delimiter)
Funktion
V_STRING('Vector GEN Delimited String To Vector'(s;delimiter);",")
F1 72a4c88 72a29e8 72a4d08 72a7b78 0 0 2
-- Vector Handling Functions --
Funktion

F1 72a4d08 72a4c88 0 72a4d88 0 0 2
GEN Vector SumElements(useVector; toElement)
Funktion
IF (toElement < 0 ; çä  0 ; çä  SUMX(i;0;MIN(toElement;V_LENGTH(useVector) - 1);E_(useVector;#i))çä)
F1 72a4d88 72a4c88 0 72a4e08 0 0 2
GEN Vector InvertElements(useVector)
Funktion
VECTORX(i;0;V_LENGTH(useVector) - 1;E_(useVector;V_LENGTH(useVector) - 1 - #i))
F1 72a4e08 72a4c88 0 72a4e88 0 0 2
GEN Vector ElementsMin(useVector; elementMax)
Funktion
VECTORX(i;0;V_LENGTH(useVector) - 1;MIN(E_(useVector;#i);elementMax))
F1 72a4e88 72a4c88 0 72a4f08 0 0 2
GEN Vector ElementsMax(useVector; elementMax)
Funktion
VECTORX(i;0;V_LENGTH(useVector) - 1;MAX(E_(useVector;#i);elementMax))
F1 72a4f08 72a4c88 0 72a4f88 0 0 2
GEN Vector Round(useVector; d)
Funktion
VECTORX(i;0;V_LENGTH(useVector) - 1;'GEN Round'(E_(useVector;#i);d))
F1 72a4f88 72a4c88 0 72a5008 0 0 2
GEN Vector Blank
Funktion
""
F1 72a5008 72a4c88 0 72a5088 0 0 2
GEN String Vector Add(stringVector1; stringVector2)
Funktion
IF (V_LENGTH(V_CONSTRUCT('INPUT String Vector 1')) = V_LENGTH(V_CONSTRUCT('INPUT String Vector 2')) ; çä  V_STRING(V_CONSTRUCT('INPUT String Vector 1') + V_CONSTRUCT('INPUT String Vector 2');"#") ; çä  ERROR("Vectors are of different lengths")çä)
F1 72a5088 72a4c88 0 72a5108 0 0 2
GEN String Vector Subtract(stringVector1; stringVector2)
Funktion
IF (V_LENGTH(V_CONSTRUCT('INPUT String Vector 1')) = V_LENGTH(V_CONSTRUCT('INPUT String Vector 2')) ; çä  V_STRING(V_CONSTRUCT('INPUT String Vector 1') + (V_CONSTRUCT('INPUT String Vector 2') * -1);"#") ; çä  ERROR("Vectors are of different lengths")çä)
F1 72a5108 72a4c88 0 72a5188 0 0 2
GEN String Vector Mult(stringVector1; stringVector2)
Funktion
IF (V_LENGTH(V_CONSTRUCT(stringVector1)) = V_LENGTH(V_CONSTRUCT(stringVector2)) ; çä  V_STRING(V_CONSTRUCT(stringVector1) * V_CONSTRUCT(stringVector2);"#") ; çä  ERROR("Vectors are of different lengths")çä)
F1 72a5188 72a4c88 0 72a5208 0 0 2
GEN Vector Ascending Sort(useVector)
Funktion
V_NUMSORT(useVector)
F1 72a5208 72a4c88 0 72a5288 0 0 2
GEN Vector Descending Sort(useVector)
Funktion
'GEN Vector InvertElements'(V_NUMSORT(useVector))
F1 72a5288 72a4c88 0 72a5308 0 0 2
GEN Vector Unique Elements(useVector; position; string; vCounter; counter)
Funktion
IF (vCounter >= V_LENGTH(useVector) ; çä  string ; çä  IF ('GEN Vector Find'(string;E_(E_(useVector;vCounter);position);0) ; çä    'GEN Vector Unique Elements'(useVector;position;string;vCounter + 1;counter) ; çä    'GEN Vector Unique Elements'(useVector;position;IF (V_LENGTH(string) = 0 ; çä      V_(E_(E_(useVector;vCounter);position)) ; çä      V_CONCAT(string;V_(E_(E_(useVector;vCounter);position)))çä    );vCounter + 1;counter + 1)çä)çä)
F1 72a5308 72a4c88 0 72a5408 0 0 2
GEN Vector Sum Specific Elements(useVector; toElement; position)
Funktion
IF (toElement < 0 ; çä  0 ; çä  SUMX(i;0;MIN(toElement;V_LENGTH(useVector) - 1);E_(E_(useVector;#i);position))çä)
F1 72a5408 72a4c88 0 72a7af8 0 0 2
GEN Vector Reduce(useVector; redVector; position; data; counter)
Funktion
IF (counter >= V_LENGTH(useVector) ; çä  redVector ; çä  IF (E_(E_(useVector;counter);position) ALIKE data ; çä    IF (V_LENGTH(redVector) = 0 ; çä      'GEN Vector Reduce'(useVector;V_(E_(useVector;counter));position;data;counter + 1) ; çä      'GEN Vector Reduce'(useVector;V_INSERT(redVector;E_(useVector;counter);V_LENGTH(redVector));position;data;counter + 1)çä    ) ; çä  'GEN Vector Reduce'(useVector;redVector;position;data;counter + 1)çä)çä)
F1 72a7af8 72a4c88 0 0 0 0 2
GEN Vector Find(useVector; find; counter)
Funktion
IF (counter >= V_LENGTH(useVector) ; çä  0 ; çä  IF (E_(useVector;counter) ALIKE find ; çä    1 ; çä    'GEN Vector Find'(useVector;find;counter + 1)çä  )çä)
F1 72a7b78 72a29e8 72a7bf8 72a7c78 0 0 2
-- Date handling functions --
Funktion

F1 72a7bf8 72a7b78 0 0 0 0 2
GEN Date to Lookup Convert(dateconvert)
Funktion
DATE(dateconvert;0;0;0;"YMD")
F1 72a7c78 72a29e8 72a7cf8 72a81f8 0 0 2
-- MM Version Info --
Funktion

F1 72a7cf8 72a7c78 72a7d78 72a7ff8 0 0 2
GEN VersionInfo
Funktion
'GEN VersionInformation'(1)
F1 72a7d78 72a7cf8 72a7df8 0 0 0 2
GEN VersionInformation(i)
Funktion
IF (i >= TABROWS(T_RepositoryInformation) ; çä  'GEN Info'(i) ; çä  IF ('GEN Exist'(i - 1;T_RepositoryInformation[i]) ; çä    'GEN VersionInformation'(i + 1) ; çä    'GEN Info'(i) & 'GEN nl' & 'GEN VersionInformation'(i + 1)çä  )çä)
F1 72a7df8 72a7d78 72a7e78 72a7f78 0 0 2
GEN Info(i)
Funktion
LEFT(T_RepositoryInformation[i];INSTR(T_RepositoryInformation[i];";") - 1) & " - " & 'GEN CUT'(SUBST('GEN Next'('GEN Next'('GEN Next'(T_RepositoryInformation[i])));";";" - "))
F1 72a7e78 72a7df8 0 72a7ef8 0 0 2
GEN Next(s)
Funktion
MID(s;INSTR(s;";") + 1)
F1 72a7ef8 72a7df8 0 0 0 0 2
GEN CUT(s)
Funktion
LEFT(s;INSTR(s;"moduleTag") - 3)
F1 72a7f78 72a7d78 0 0 0 0 2
GEN Exist(i;s)
Funktion
IF ( /*If recursion stopping point has been reached*/ i < 1 ; çä   /*stop*/ 1 ; çä   /*Keep going*/ NOT(TRIM(MID(T_RepositoryInformation[i];INSTR(T_RepositoryInformation[i];"parent"))) ALIKE TRIM(MID(s;INSTR(s;"parent")))) && 'GEN Exist'(i - 1;s)çä)
F1 72a7ff8 72a7c78 72a8078 72a8178 0 0 2
GEN Version
Funktion
'GEN Versions'(1;TABROWS(T_RepositoryInformation))
F1 72a8078 72a7ff8 72a80f8 0 0 0 2
GEN Versions(i; tabrow)
Funktion
IF (i >= tabrow ; çä  SUBST(T_RepositoryInformation[tabrow];";";'GEN nl') ; çä  SUBST(T_RepositoryInformation[i];";";'GEN nl') & 'GEN nl' & 'GEN nl' & 'GEN Versions'(i + 1;tabrow)çä)
F1 72a80f8 72a8078 0 0 0 0 2
GEN nl
Funktion
chr(10)
F1 72a8178 72a7c78 0 0 0 0 2
nl
Funktion
chr(10)
F1 72a81f8 72a29e8 72a8278 72a87f8 0 0 2
-- Other General Functions --
Funktion

F1 72a8278 72a81f8 0 72a82f8 0 0 2
GEN Future Value Factor(int_rate; n)
Funktion
(1 + (int_rate * 0.01)) ^ n
F1 72a82f8 72a81f8 0 72a8378 0 0 2
GEN Months In Paymode(mode)
Funktion
CASE( /*mode*/ MODE;çä   // Annualçä1 : 12;çä   // Semi-annualçä2 : 6;çä   // Quarterlyçä3 : 3;çä   // Monthlyçä4 : 1;çä   // otherçä : 0)çä
F1 72a8378 72a81f8 0 72a83f8 0 0 2
GEN Payments In Year(mode)
Funktion
CASE( /*Mode*/ mode;çä   // Annualçä1 : 1;çä   // Semi-annualçä2 : 2;çä   // Quarterlyçä3 : 4;çä   // Monthlyçä4 : 12;çä   // otherçä : 0)çä
F1 72a83f8 72a81f8 0 72a8478 0 0 2
GEN Interpolate(value1; value2; periods_since_value1; total_periods)
Funktion
(value2 * (periods_since_value1 / total_periods)) + (value1 * ((total_periods - periods_since_value1) / total_periods))
F1 72a8478 72a81f8 72a84f8 72a8778 0 0 2
GEN OrderedReleaseAmt(releaseAmount; bucketIndex; bucketValueVector; releaseType)
Funktion
'GEN Round'(CASE('GEN Release Type Coversion'(releaseType);çä  "FIFO" : 'GEN OrderedReleaseAmt FIFO'(releaseAmount;bucketIndex;'GEN Vector ElementsMax'(bucketValueVector;0));çä  "LIFO" : 'GEN OrderedReleaseAmt FIFO'(releaseAmount;V_LENGTH(bucketValueVector) - 1 - bucketIndex;'GEN Vector InvertElements'('GEN Vector ElementsMax'(bucketValueVector;0)));çä  "ProRata" : 'GEN OrderedReleaseAmt ProRata'(releaseAmount;bucketIndex;'GEN Vector ElementsMax'(bucketValueVector;0));çä   //"Specified" : 'GEN OrderedReleaseAmt Specified'(releaseAmount; bucketIndex; 'Policy Investment WithdrawalAllocation SpecifiedFund'; bucketValueVector);çä : 0)çä + IF (bucketIndex = V_LENGTH(bucketValueVector) - 1 ; çä  MAX(releaseAmount - 'GEN Vector SumElements'('GEN Vector ElementsMax'(bucketValueVector;0);V_LENGTH(bucketValueVector) - 1);0) ; çä  0çä);8)
F1 72a84f8 72a8478 0 72a8578 0 0 2
GEN OrderedReleaseAmt FIFO(releaseAmount; bucketIndex; bucketValueVector)
Funktion
IF ('GEN Vector SumElements'(bucketValueVector;bucketIndex - 1) >= releaseAmount ; çä  0 ; çä  IF ('GEN Vector SumElements'(bucketValueVector;bucketIndex) <= releaseAmount ; çä    E_(bucketValueVector;bucketIndex) ; çä    releaseAmount - 'GEN Vector SumElements'(bucketValueVector;bucketIndex - 1)çä  )çä)
F1 72a8578 72a8478 0 72a85f8 0 0 2
GEN OrderedReleaseAmt ProRata(releaseAmount; bucketIndex; bucketValueVector)
Funktion
IF ('GEN Vector SumElements'(bucketValueVector;V_LENGTH(bucketValueVector) - 1) = 0 ; çä  0 ; çä  MIN(releaseAmount / 'GEN Vector SumElements'(bucketValueVector;V_LENGTH(bucketValueVector) - 1);1) * E_(bucketValueVector;bucketIndex)çä)
F1 72a85f8 72a8478 0 72a86f8 0 0 2
GEN Release Type Coversion(releaseType)
Funktion
CASE(releaseType;çä  1 : "LIFO";çä  2 : "ProRata";çä  5 : "FIFO";çä  1000500001 : "Specified";çä   : releaseType)çä
F1 72a86f8 72a8478 0 0 0 0 2
GEN OrderedReleaseAmt Specified(releaseAmount; bucketIndex; specifiedFund; bucketValueVector)
Funktion
IF (bucketIndex = specifiedFund ; çä  MIN(releaseAmount;E_(bucketValueVector;specifiedFund)) ; çä   //If balance remaining, allocate pro rata to other fundsâââçäIF ((releaseAmount > E_(bucketValueVector;specifiedFund)) ; çä    'GEN OrderedReleaseAmt ProRata'(releaseAmount - E_(bucketValueVector;specifiedFund);bucketIndex;V_REPLACE(bucketValueVector;specifiedFund;0)) ; çä    0çä  )çä)
F1 72a8778 72a81f8 0 0 0 0 2
GEN Not Str or Zero(value1)
Funktion
ISNUMBER(value1) && value1 > 0
F1 72a87f8 72a29e8 72a8878 72acd98 0 0 2
-- IRR --
Funktion

F1 72a8878 72a87f8 72a88f8 72ac298 0 0 2
GEN IRR(cashFlowVector; solveAmount; initGuess; tolerance; roundInt)
Funktion
IF ('GEN IRR Calculable'(cashFlowVector;solveAmount) ; çä  IF ('GEN IRR Solve Successful'('GEN IRR Internal'(cashFlowVector;solveAmount;initGuess;tolerance;roundInt)) ; çä    'GEN Round'('GEN IRR Internal'(cashFlowVector;solveAmount;initGuess;tolerance;roundInt);roundInt) ; çä    IF ('GEN IRR Solve Successful'('GEN IRR Model'(cashFlowVector;solveAmount;initGuess;tolerance;roundInt)) ; çä      'GEN Round'('GEN IRR Model'(cashFlowVector;solveAmount;initGuess;tolerance;roundInt);roundInt) ; çä      -100çä    )çä) ; çä-100çä)
F1 72a88f8 72a8878 0 72a8978 0 0 2
GEN IRR Calculable(cashFlowVector; solveAmount)
Funktion
NOT(solveAmount < 0 || 'GEN Vector SumElements'(cashFlowVector;V_LENGTH(cashFlowVector) - 1) = 0)
F1 72a8978 72a8878 0 72a89f8 0 0 2
GEN IRR Solve Successful(solveResult)
Funktion
ISNUMBER(solveResult)
F1 72a89f8 72a8878 0 72ac098 0 0 2
GEN IRR Internal(cashFlowVector; solveAmount; initGuess; tolerance; roundInt)
Funktion
 /* Call to new standard function IRR (Internal Rate of Return)çä   IRR(vCashflow; rReturnAmount; iPeriods, rInitialGuess; rToleranceAmount; iRoundDecimals)çä   where vCashflow is a vector of the cash flow amount at the beginning of each yearçä  âârReturnAmount is a real number for the amount returned at the end of the investment periodçä  ââiPeriods is number of years in the investment periodçä  âârInitialGuess is real number for the initial guess at the IRR, in decimal formatçä                       for example, enter 0.10 for an initial guess of 10%çä        rToleranceAmount is real number for tolerance around target amountçä        iRoundDecimals is integer number of decimal places to round final result (not currently supported)çä*/ IRR(cashFlowVector;solveAmount;V_LENGTH(cashFlowVector);initGuess;tolerance;roundInt)
F1 72ac098 72a8878 72ac118 0 0 0 2
GEN IRR Model(cashFlowVector; solveAmount; initGuess; tolerance; roundInt)
Funktion
'GEN IRR Model Rec'(cashFlowVector;solveAmount;0;initGuess;tolerance;0)
F1 72ac118 72ac098 0 72ac198 0 0 2
GEN IRR Model Rec(cashFlowVector; solveAmount; prevGuess; currGuess; tolerance; iter)
Funktion
IF (iter > 100 ; çä  MESSAGE("IRR: Maximum Iterations reached";currGuess) ; çä  IF (iter <> 1 && ABS(currGuess - prevGuess) < tolerance ; çä    currGuess ; çä    'GEN IRR Model Rec'(cashFlowVector;solveAmount;currGuess;'GEN IRR newGuess'(cashFlowVector;solveAmount;prevGuess;currGuess);tolerance;iter + 1)çä  )çä)
F1 72ac198 72ac098 0 72ac218 0 0 2
GEN IRR newGuess(cashFlowVector; solveAmount; prevGuess; currGuess)
Funktion
(0 - 'GEN IRR Targeting'(cashFlowVector;solveAmount;currGuess)) / ('GEN IRR Targeting'(cashFlowVector;solveAmount;currGuess) - 'GEN IRR Targeting'(cashFlowVector;solveAmount;prevGuess)) * (currGuess - prevGuess) + currGuess
F1 72ac218 72ac098 0 0 0 0 2
GEN IRR Targeting(cashFlowVector; solveAmount; currGuess)
Funktion
solveAmount - SUMX(dur;0;V_LENGTH(cashFlowVector) - 1;E_(cashFlowVector;#dur) * (1 + currGuess) ^ (V_LENGTH(cashFlowVector) - #dur))
F1 72ac298 72a87f8 72ac318 0 0 0 2
GEN IRR NP(cashFlowVector; solveAmount; solveDate; initGuess; tolerance; roundInt)
Funktion
 //Description of parametersçä// cashFlowVector  - vector of cash flows, with each element being a vectorçä//                                consisting of the cash flow amount and the cash flow dateçä//                                a positive cash flow represents an investment into the contract, a negative cash flow represents a withdrawalçä//                                from the investmentçä// solveAmount  - amount returned by the investmentçä// solveDate - date at the end of the investment periodçä// initGuess  - initial guess to seed the iteration process (in percent format)çä// roundInt - number of decimal places to round the final result to (in percent format)çäIF ('GEN IRR Calculable'(cashFlowVector;solveAmount) ; çä  IF ('GEN IRR Solve Successful'('GEN IRR NP Solve'(cashFlowVector;solveAmount;solveDate;initGuess;tolerance;roundInt)) ; çä    'GEN Round'('GEN IRR NP Solve'(cashFlowVector;solveAmount;solveDate;initGuess;tolerance;roundInt);roundInt) ; çä    IF ('GEN IRR Solve Successful'('GEN IRR NP Model'(initGuess;V_(cashFlowVector;solveAmount;solveDate;initGuess;tolerance;roundInt))) ; çä      'GEN Round'('GEN IRR NP Model'(initGuess;V_(cashFlowVector;solveAmount;solveDate;initGuess;tolerance;roundInt));roundInt) ; çä      -100çä    )çä) ; çä-100çä)
F1 72ac318 72ac298 72ac398 72ac598 0 0 2
GEN IRR NP Solve(cashFlowVector; solveAmount; solveDate, initGuess; tolerance; roundInt)
Funktion
 //    New function solve()çä//    solve(iMethod,ref_F,ref_F_dx,r_Target,rGuess,rTolerance,rLow,rHigh,iIterLimit,vConstant)çä// çäSOLVE(2; //Newton-RaphsonçäFUNCREF('GEN IRR NP AccruedCFs'); // function ref to receive currGuess and vector of ConstantsçäFUNCREF('GEN IRR NP AccruedCFs Derivative'); // used in Newton  funcref(fIRRd)çäsolveAmount; //target value çäinitGuess; // initial guessçätolerance; // toleranceçä'GEN IRR NP lowBound'; // Low IRR boundary çä'GEN IRR NP highBound'; // High IRR boundaryçä100; // iteration limitçäV_(cashFlowVector;solveAmount;solveDate))
F1 72ac398 72ac318 72ac418 72ac498 0 0 2
GEN IRR NP lowBound
Funktion
-1
F1 72ac418 72ac398 0 0 0 0 2
GEN IRR NP Reset lowBound(currIRRGuess; currAccruedCFs; prevIRRGuess; prevAccruedCFs; lowBound; highBound; iter; solveVector)
Funktion
IF ( /* New low boundary found*/ currAccruedCFs < 'GEN IRR solve InvestmentReturnAmount'(solveVector) ; çä   /*return new low boundary*/ MAX(lowBound;currIRRGuess) ; çä   /*old low boundary*/ lowBoundçä)
F1 72ac498 72ac318 72ac518 0 0 0 2
GEN IRR NP highBound
Funktion
10000
F1 72ac518 72ac498 0 0 0 0 2
GEN IRR NP Reset highBound(currIRRGuess; currAccruedCFs; prevIRRGuess; prevAccruedCFs; lowBound; highBound; iter; solveVector)
Funktion
IF ( /* New high boundary found*/ currAccruedCFs > 'GEN IRR solve InvestmentReturnAmount'(solveVector) ; çä   /*Return new high boundary*/ MIN(highBound;currIRRGuess) ; çä   /*old high boundary*/ highBoundçä)
F1 72ac598 72ac298 72ac618 72ac798 0 0 2
GEN IRR NP Model(initGuess; vConstants)
Funktion
E_('GEN IRR NP Model Rec'(initGuess;'GEN IRR NP AccruedCFs'(initGuess;vConstants);0;0;'GEN IRR NP lowBound';'GEN IRR NP highBound';1;vConstants);0)
F1 72ac618 72ac598 72ac698 0 0 0 2
GEN IRR NP Model Rec(currIRRGuess; currAccruedCFs; prevIRRGuess; prevAccruedCFs; lowBound; highBound; iter; solveVector)
Funktion
 //  Description of parmsçä// currIRRGuess - current guess for IRR for this iterationçä// currAccruedCFs - current accrued cash flows for this iterationçä// prevIRRGuess - previous guess for IRR for this iterationçä// prevAccruedCFs - previous accrued cash flows for this iterationçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return date, initial guess,çä//                                           tolerance amount, round decimalsçäIF ('GEN IRR NP ToleranceReached'(currIRRGuess;prevIRRGuess;currAccruedCFs;solveVector) ; çä   //|| iteration_num = A_requested_stop_iteration;çä// Stop if target reached, guess amounts within tolerance, or requested stop iteration reachedçäV_(currIRRGuess;currAccruedCFs;iter) ; çä   /*Keep looking if tolerance not reached*/ IF ( /*if we can't get a successful result after 100 iterations*/ iter > 100 ; çä     /*Give up and return string 'NORES' for No Result */ "NORES" ; çä     //Too many iterations -- did not convergeçä/*Else call this function recursively again*/'GEN IRR NP Model Rec'( // New IRR guessçä'GEN IRR NP NextGuess'(currIRRGuess;currAccruedCFs;prevIRRGuess;prevAccruedCFs;lowBound;highBound;iter;solveVector); // New Current Accrued Net Annual Outlaysçä'GEN IRR NP AccruedCFs'('GEN IRR NP NextGuess'(currIRRGuess;currAccruedCFs;prevIRRGuess;prevAccruedCFs;lowBound;highBound;iter;solveVector);solveVector); // New Previous IRR guessçäcurrIRRGuess; // New Previous Accrued Cash FlowsçäcurrAccruedCFs;'GEN IRR NP Reset lowBound'(currIRRGuess;currAccruedCFs;prevIRRGuess;prevAccruedCFs;lowBound;highBound;iter;solveVector);'GEN IRR NP Reset highBound'(currIRRGuess;currAccruedCFs;prevIRRGuess;prevAccruedCFs;lowBound;highBound;iter;solveVector);iter + 1;solveVector)çä  )çä)
F1 72ac698 72ac618 0 72ac718 0 0 2
GEN IRR NP ToleranceReached(currIRRGuess; prevIRRGuess; currAccruedCFs; solveVector)
Funktion
(ROUND(prevIRRGuess;'GEN IRR solve RoundDecimals'(solveVector) + 2) = ROUND(currIRRGuess;'GEN IRR solve RoundDecimals'(solveVector) + 2)) || (ABS(currAccruedCFs - 'GEN IRR solve InvestmentReturnAmount'(solveVector)) < 'GEN IRR solve ToleranceAmount'(solveVector))
F1 72ac718 72ac618 0 0 0 0 2
GEN IRR NP NextGuess(currIRRGuess; currAccruedCFs; prevIRRGuess; prevAccruedCFs; lowBound; highBound; iter; solveVector)
Funktion
IF (iter < 100 ; çä   /*Newton-Raphson iteration*/ MAX(currIRRGuess - (currAccruedCFs - 'GEN IRR solve InvestmentReturnAmount'(solveVector)) / 'GEN IRR NP AccruedCFs Derivative'(currIRRGuess;solveVector);-1) ; çä   /*Bisection method*/ IF ( /*Premium guess too low*/ currAccruedCFs < 'GEN IRR solve InvestmentReturnAmount'(solveVector) ; çä     /*IRR guess is too low;  Increase IRR guess*/ (MAX(lowBound;currIRRGuess) + highBound) * 0.5 ; çä     /*IRR guess is too high; Decrease IRR guess*/ (lowBound + MIN(highBound;currIRRGuess)) * 0.5çä  )çä)
F1 72ac798 72ac298 72ac818 72ac898 0 0 2
GEN IRR NP AccruedCFs(currGuess; vConstants)
Funktion
SUMX(CF_index;1;V_LENGTH(E_(vConstants;0));'GEN IRR NP AccruedCF for Item'(E_(E_(E_(vConstants;0);#CF_index - 1);0);E_(E_(E_(vConstants;0);#CF_index - 1);1);currGuess;E_(vConstants;2)))
F1 72ac818 72ac798 0 0 0 0 2
GEN IRR NP AccruedCF for Item(cashFlow; cashFlowDate; interestRate; solveDate)
Funktion
cashFlow * (1 + interestRate) ^ ((DATEDAY(solveDate) - DATEDAY(cashFlowDate)) / 365)
F1 72ac898 72ac298 72ac918 72ac998 0 0 2
GEN IRR NP AccruedCFs Derivative(currGuess;vConstants)
Funktion
SUMX(CF_index;1;V_LENGTH(E_(vConstants;0));'GEN IRR NP AccruedCF Derivative for Item'(E_(E_(E_(vConstants;0);#CF_index - 1);0);E_(E_(E_(vConstants;0);#CF_index - 1);1);currGuess;E_(vConstants;2)))
F1 72ac918 72ac898 0 0 0 0 2
GEN IRR NP AccruedCF Derivative for Item(cashFlow; cashFlowDate; interestRate; solveDate)
Funktion
 /* Derivative of Cash Flow - for Newton-Raphson iteration */ ((DATEDAY(solveDate) - DATEDAY(cashFlowDate)) / 365) * (cashFlow * (1 + interestRate) ^ (((DATEDAY(solveDate) - DATEDAY(cashFlowDate)) / 365) - 1))
F1 72ac998 72ac298 72aca18 0 0 0 2
--Solve vector extract functions--
Funktion

F1 72aca18 72ac998 0 72aca98 0 0 2
GEN IRR solve CashFlowVector(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;0)
F1 72aca98 72ac998 0 72acb18 0 0 2
GEN IRR solve InvestmentReturnAmount(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;1)
F1 72acb18 72ac998 0 72acb98 0 0 2
GEN IRR solve InvestmentReturnPeriod(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;2)
F1 72acb98 72ac998 0 72acc18 0 0 2
GEN IRR solve InitialGuess(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;3)
F1 72acc18 72ac998 0 72acc98 0 0 2
GEN IRR solve InvestmentReturnDate(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;2)
F1 72acc98 72ac998 0 72acd18 0 0 2
GEN IRR solve ToleranceAmount(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;4)
F1 72acd18 72ac998 0 0 0 0 2
GEN IRR solve RoundDecimals(solveVector)
Funktion
 //Passed parmsçä// solveVector - vector of parms passed to standard internal functionçä//                         consists of cash flow vector, investment return amount, invest return period, initial guess,çä//                                           tolerance amount, round decimalsçäE_(solveVector;5)
F1 72acd98 72a29e8 72ace18 72b0f28 0 0 2
-- Allocation Functions --
Funktion
"use Vector Parm Orderçä çä0:âAllocation Sequence (Date is the currently supported option)çä1:âAllocation Basis (Amount used for the allocation - account Value etc...)çä2:âFlow ID (This is specific to wmA-J)çä3:âFund Codeçä4:âDiscount factor (This is specific to wmA-J)çä çäReturns a vector of çä çä0:âDateçä1:âAllocated Amountçä2:  Flow IDçä3:  Fund Code
F1 72ace18 72acd98 72ace98 c56aa81 0 0 2
GEN Allocation(allocType; allocAmt; roundDecimals; useVector)
Funktion
CASE(allocType;çä  "PCT" : 'GEN PCT Alloc'(allocAmt;roundDecimals;useVector);çä  "FIFO" : 'GEN AMT Alloc'(allocAmt;'GEN Vector Ascending Sort'(useVector));çä  "LIFO" : 'GEN AMT Alloc'(allocAmt;'GEN Vector Descending Sort'(useVector));çä  "AMT" : 'GEN AMT Alloc'(allocAmt;IF ('GEN useVector SortFactor'(E_(useVector;0)) > 0 ; çä    'GEN Vector Ascending Sort'(useVector) ; çä    useVectorçä  ));çä"PROP" : 'GEN PROP Alloc'(allocAmt;roundDecimals;'GEN Vector Ascending Sort'(useVector)))çä
F1 72ace98 72ace18 72acf18 72acf98 0 0 2
GEN AMT Alloc(allocAmt; useVector)
Funktion
VECTORX(e;0;V_LENGTH(useVector) - 1;V_('GEN useVector Sort Date'(E_(useVector;#e));IF ('GEN Rem allocAmt'(#e;allocAmt;useVector) >= 'GEN useVector AllocationBasis'(E_(useVector;#e)) && 'Std Calling System Is wmaJ' && 'GEN useVector DiscountFactor'(E_(useVector;#e)) > 1 ; çä  'GEN useVector RemainingDeposit'(E_(useVector;#e)) ; çä  'GEN Round'(IF (#e = V_LENGTH(useVector) - 1 ; çä    'GEN Rem allocAmt'(#e;allocAmt;useVector) ; çä    MIN('GEN Rem allocAmt'(#e;allocAmt;useVector);'GEN useVector AllocationBasis'(E_(useVector;#e)))çä  ) / IF ('Std Calling System Is wmaJ' ; çä  'GEN useVector DiscountFactor'(E_(useVector;#e)) ; çä  1çä);'GEN Allocated Rounding'('GEN useVector FundCode'(E_(useVector;#e))) //Jacoçä)çä);'GEN useVector FlowID'(E_(useVector;#e));'GEN useVector FundCode'(E_(useVector;#e))))
F1 72acf18 72ace98 0 0 0 0 2
GEN Rem allocAmt(toElement; allocAmt; useVector)
Funktion
IF (toElement <= 0 ; çä  allocAmt ; çä  MAX(allocAmt - SUMX(i;0;MIN(toElement - 1;V_LENGTH(useVector) - 1);'GEN useVector AllocationBasis'(E_(useVector;#i)));0)çä)
F1 72acf98 72ace18 72b0728 72b07a8 0 0 2
GEN PCT Alloc(allocAmt; roundDecimals; useVector)
Funktion
VECTORX(e;0;V_LENGTH(useVector) - 1;V_('GEN useVector Sort Date'(E_(useVector;#e));IF ('GEN Rem allocPct'(#e;allocAmt;roundDecimals;useVector) >= 'GEN Round'(allocAmt * 'GEN useVector AllocationBasis'(E_(useVector;#e));roundDecimals) && 'Std Calling System Is wmaJ' && 'GEN useVector DiscountFactor'(E_(useVector;#e)) > 1 ; çä  'GEN useVector RemainingDeposit'(E_(useVector;#e)) ; çä  'GEN Round'(IF (#e = V_LENGTH(useVector) - 1 ; çä    'GEN Rem allocPct'(#e;allocAmt;roundDecimals;useVector) ; çä    MIN('GEN Rem allocPct'(#e;allocAmt;roundDecimals;useVector);'GEN Round'(allocAmt * 'GEN useVector AllocationBasis'(E_(useVector;#e));roundDecimals))çä  ) / IF ('Std Calling System Is wmaJ' ; çä  'GEN useVector DiscountFactor'(E_(useVector;#e)) ; çä  1çä);2)çä);'GEN useVector FlowID'(E_(useVector;#e));'GEN useVector FundCode'(E_(useVector;#e))))
F1 72b0728 72acf98 0 0 0 0 2
GEN Rem allocPct(toElement; allocAmt; roundDecimals; useVector)
Funktion
IF (toElement <= 0 ; çä  allocAmt ; çä  allocAmt - SUMX(i;0;MIN(toElement - 1;V_LENGTH(useVector) - 1);'GEN Round'(allocAmt * 'GEN useVector AllocationBasis'(E_(useVector;#i));roundDecimals))çä)
F1 72b07a8 72ace18 6980888b 0 0 0 2
GEN PROP Alloc(allocAmt; roundDecimals; useVector)
Funktion
VECTORX(e;0;V_LENGTH(useVector) - 1;V_('GEN useVector Sort Date'(E_(useVector;#e)); //Rounding addedçä'GEN Round'(IF (#e = V_LENGTH(useVector) - 1 ; çä  'GEN Rem allocProp'(#e;allocAmt;roundDecimals;useVector) ; çä   //jââââ'GEN Round'(çäallocAmt * 'GEN useVector AllocationBasis'(E_(useVector;#e)) / 'GEN Vector Sum Specific Elements'(useVector;V_LENGTH(useVector);1) //j; çä//jâââââroundDecimalsçä//jââââ)çäçä) / IF ('Std Calling System Is wmaJ' ; çä'GEN useVector DiscountFactor'(E_(useVector;#e)) ; çä1çä);roundDecimals);'GEN useVector FlowID'(E_(useVector;#e));'GEN useVector FundCode'(E_(useVector;#e))))
F1 6980888b 72b07a8 0 0 0 0 2
GEN Rem allocProp(toElement; allocAmt; roundDecimals; useVector)
Funktion
IF (toElement <= 0 ; çä  allocAmt ; çä  allocAmt - SUMX(i;0;MIN(toElement - 1;V_LENGTH(useVector) - 1);'GEN Round'(allocAmt * 'GEN useVector AllocationBasis'(E_(useVector;#i)) / 'GEN Vector Sum Specific Elements'(useVector;V_LENGTH(useVector);1);roundDecimals))çä)
F1 c56aa81 72acd98 825bab7 72b0828 0 0 2
GEN Allocated Rounding(useVector)
Funktion
IF (useVector ALIKE "VA1" || useVector ALIKE "VA2" ; çä  4 ; çä  2çä) //GEN Rounding Test(useVector)ä
F1 825bab7 c56aa81 0 0 0 0 2
GEN Rounding FundCode(useVector; counter)
Funktion
E_('GEN Vector Unique Elements'(useVector;3;"";0;0);counter)
F1 72b0828 72acd98 72b08a8 72b0c28 0 0 2
-- Allocation Vector Readability --
Funktion

F1 72b08a8 72b0828 0 72b0928 0 0 2
GEN useVector SortFactor(useVector)
Funktion
E_(useVector;0)
F1 72b0928 72b0828 0 72b09a8 0 0 2
GEN useVector Sort Date(useVector)
Funktion
IF ('GEN useVector SortFactor'(useVector) > 693596 ; çä  DAYDATE('GEN useVector SortFactor'(useVector);"M/D/Y") ; çä  'GEN useVector SortFactor'(useVector)çä)
F1 72b09a8 72b0828 0 72b0a28 0 0 2
GEN useVector FundCode(useVector)
Funktion
IF (V_LENGTH(useVector) > 3 ; çä  E_(useVector;3) ; çä  'GEN vector Blank'çä)
F1 72b0a28 72b0828 0 72b0aa8 0 0 2
GEN useVector FlowID(useVector)
Funktion
IF (V_LENGTH(useVector) > 2 ; çä  E_(useVector;2) ; çä  'GEN vector Blank'çä)
F1 72b0aa8 72b0828 0 72b0b28 0 0 2
GEN useVector DiscountFactor(useVector)
Funktion
IF (V_LENGTH(useVector) > 4 ; çä  E_(useVector;4) ; çä  'GEN vector Blank'çä)
F1 72b0b28 72b0828 0 72b0ba8 0 0 2
GEN useVector RemainingDeposit(useVector)
Funktion
IF (V_LENGTH(useVector) > 5 ; çä  E_(useVector;5) ; çä  'GEN vector Blank'çä)
F1 72b0ba8 72b0828 0 0 0 0 2
GEN useVector AllocationBasis(useVector)
Funktion
E_(useVector;1)
F1 72b0c28 72acd98 72b0ca8 0 0 0 2
GEN Allocated Withdrawals(calcType; useVector; withdrawalAmt; allocType)
Funktion
'GEN Allocated Withdrawals Rec'(calcType;useVector;withdrawalAmt;0;'GEN Vector Blank';allocType)
F1 72b0ca8 72b0c28 72b0d28 72b0da8 0 0 2
GEN Allocated Withdrawals Rec(calcType; useVector; withdrawalAmt; counter; finalVector; allocType)
Funktion
IF (counter >= V_LENGTH('GEN Vector Unique Elements'(useVector;3;"";0;0)) ; çä  finalVector ; çä  IF (V_LENGTH(finalVector) = 0 ; çä    'GEN Allocated Withdrawals Rec'(calcType;useVector;withdrawalAmt;counter + 1;'GEN Allocation'(allocType;'GEN Fund Withdrawal Amt'(calcType;withdrawalAmt;E_('GEN Vector Unique Elements'(useVector;3;"";0;0);counter);useVector);'GEN Allocated Rounding'('GEN Rounding FundCode'(useVector;counter)); //Jacoçä'GEN Vector Reduce'(useVector;"";3;E_('GEN Vector Unique Elements'(useVector;3;"";0;0);counter);0));allocType) ; çä    'GEN Allocated Withdrawals Rec'(calcType;useVector;withdrawalAmt;counter + 1;'GEN Vector Insert'(finalVector;'GEN Allocation'(allocType;'GEN Fund Withdrawal Amt'(calcType;withdrawalAmt;E_('GEN Vector Unique Elements'(useVector;3;"";0;0);counter);useVector);'GEN Allocated Rounding'('GEN Rounding FundCode'(useVector;counter)); //Jacoçä'GEN Vector Reduce'(useVector;"";3;E_('GEN Vector Unique Elements'(useVector;3;"";0;0);counter);0));0);allocType)çä  )çä)
F1 72b0d28 72b0ca8 0 0 0 0 2
GEN Vector Insert(finalVector; useVector; counter)
Funktion
IF (counter >= V_LENGTH(useVector) ; çä  finalVector ; çä  'GEN Vector Insert'(V_INSERT(finalVector;E_(useVector;counter);0);useVector;counter + 1)çä)
F1 72b0da8 72b0c28 72b0e28 0 0 0 2
GEN Fund Withdrawal Amt(calcType; withdrawalAmt; fundCode; useVector)
Funktion
'GEN Round'(withdrawalAmt * 'GEN Fund Accumulation Value'(fundCode;useVector) / 'GEN Total Accumulation Value'(fundCode;useVector);2)
F1 72b0e28 72b0da8 0 72b0ea8 0 0 2
GEN Total Accumulation Value(fundCode; useVector)
Funktion
SUMX(counter;0;V_LENGTH(useVector) - 1;E_(E_(useVector;#counter);1))
F1 72b0ea8 72b0da8 0 0 0 0 2
GEN Fund Accumulation Value(fundCode; useVector)
Funktion
SUMX(counter;0;V_LENGTH(useVector) - 1;IF (E_(E_(useVector;#counter);3) ALIKE fundCode ; çä  E_(E_(useVector;#counter);1) ; çä  0çä))
F1 72b0f28 72a29e8 72b0fa8 78458005 0 0 2
-- wmA-J Flow Returns --
Funktion

F1 72b0fa8 72b0f28 72b1028 72b1128 0 0 2
GEN Vector String Conversion(useVector)
Funktion
'GEN Vector String Conversion Rec'(useVector;'GEN Vector Blank';0)
F1 72b1028 72b0fa8 0 72b10a8 0 0 2
GEN Vector String Conversion Rec(useVector; string; counter)
Funktion
IF (counter >= V_LENGTH(useVector) ; çä  string ; çä  'GEN Vector String Conversion Rec'(useVector;string & IF (LENGTH(string) > 0 ; çä    "#" ; çä    ""çä  ) & IF ('GEN useVector FlowID'(E_(useVector;counter)) ALIKE "FlowID" ; çä  "" ; çä  'GEN useVector FlowID'(E_(useVector;counter)) & ";"çä) & 'GEN useVector FundCode'(E_(useVector;counter)) & ";" & 'GEN useVector AllocationBasis'(E_(useVector;counter));counter + 1)çä)
F1 72b10a8 72b0fa8 0 0 0 0 2
GEN Vector of Vectors String Conversion(useVector; delimiter1; delimiter2)
Funktion
V_STRING(VECTORX(rateCounter;0;(V_LENGTH(useVector) - 1);V_STRING(E_(useVector;#rateCounter);delimiter1));delimiter2)
F1 72b1128 72b0f28 72b11a8 0 0 0 2
GEN Vector Fund Summary(useVector)
Funktion
VECTORX(fundCounter;0;V_LENGTH('GEN Fund Name Vector'(useVector)) - 1;V_("Date";SUMX(vCounter;0;V_LENGTH(useVector) - 1;IF ('GEN useVector FundCode'(E_(useVector;#vCounter)) ALIKE E_('GEN Fund Name Vector'(useVector);#fundCounter) ; çä  'GEN useVector AllocationBasis'(E_(useVector;#vCounter)) ; çä  0çä));"FlowID";E_('GEN Fund Name Vector'(useVector);#fundCounter)))
F1 72b11a8 72b1128 0 0 0 0 2
GEN Fund Name Vector(useVector)
Funktion
'GEN Vector Unique Elements'(useVector;3;"";0;0)
F1 78458005 72a29e8 7f639b96 0 0 0 2
-- Decision Functions --
Funktion

F1 7f639b96 78458005 0 0 0 0 2
If Applicable(value1; value2)
Funktion
IF (value1 NOTALIKE "N/A" ; çä  value1 ; çä  value2çä)
F1 72b1228 72a072c 0 0 0 0 2
Gen Vector 1
Funktion
V_(V_(20110101;1000);V_(20110401;1300);V_(20110501;1400);V_(20110801;1700);V_(20110901;1800);V_(20111201;2100);V_(20110201;1100);V_(20110301;1200);V_(20110601;1500);V_(20110701;1600);V_(20111001;1900);V_(20111101;2000))
A0 72a081c 0 72b13a8 0 0 0 0

A1 72b13a8 72a081c 0 72b1428 0 0 2
INPUT String Vector 1
default
"4"
A1 72b1428 72a081c 0 0 0 0 2
INPUT String Vector 2
default
"5"
T0 72a0894 0 72b14a8 0 0 0 0

T10 72b14a8 72a0894 0 0 0 0 2
T_RepositoryInformation
key
value1
1
ModelName=1;2;3;4;5;6;7;8;9
2
Repository
3
isDirty
4
Revision
5
Tag
6
Time
7
moduleTag
8
IsModuleDirty
9
Parent
I0 72a090c 0 72b1528 0 0 0 0

I0 72b1528 72a090c 0 0 0 0 0
DefaultFunctions.pms
-
O0
E0
L0
B0
P2
72a28e8
72a2968
F2
72a29e8
72b1228
A2
72b13a8
72b1428
T1
72b14a8
!110
72a2ae8 -2 -2
Description:  Rounds 'n' up to the higher 'd'th decimal place.çä                     Parameters: 'n'=number; 'd'=decimalsçä çäModification Log:çä5/22/2012 - wmA-J - rm - moved function comments to function noteçä10/31/2007 CSC Initial Calculation/Rule
72a2b68 -2 -2
Description: Truncates n after the dth decimal place.çä                    Parameters: 'n'=number; 'd'=decimalsçä çäModification Log:çä5/22/2012 - wmA-J - rm - moved function comments to function noteçä10/31/2007 CSC Initial Calculation/Rule
72a4508 -2 -2
Description: Rounds n rounded to the dth decimal.çä                    Parameters: 'n'=number; 'd'=decimalsçä çäModification log:çä05/26/2011 wmA-J CMC added rounding for vectorsçä02/19/2008 CSC Illustrations ILLUS001  Edited to not round if d = 15 or greater.çä10/31/2007 CSC Initial Calculation/Rule
34ab40a4 -2 -2
çäModification log:çä01/13/2015 wmA-JSC added rounding for Unit Valuesçä
72a4608 -2 -2
Description:  If the "value" parameter equals "if_value", then the "then_value" parameter is returned as a result.çä                     Otherwise, the "value" parameter is returned.çä çäModification log:çä10/31/2007 CSC Initial Calculation/Rule
72a4688 -2 -2
Description:  Searches for subs in str and returns the position (counting from 1 onwards) or 0 if not found.çä çäModification Log:çä5/22/2012 - wmA-J - rm - moved function comments to function noteçä04/25/2007âpAâBase function
72a4708 -2 -2
 Description:  Recursive search for subs in str and returns the position (counting from 1 onwards) or 0 if not found.çä çä Modification Log:çä10/31/2007 CSC Initial Calculation/Ruleçä
72a4788 -2 -2
Description: Returns 1 if value = NULL, otherwise 0çä                    Parameter: 'value' = string valueçä çäModification Log:çä5/22/2012 - rm - Simplified Boolean expression.  No IF statement necessaryçä10/31/2007 CSC Initial Calculation/Ruleçä
72a4808 -2 -2
Description: Returns the last character position of 'character' in 'str'.çä                    Parameters: 'str' = string, 'character' = string characterçä çäModification Log:çä10/31/2007 CSC Initial Calculation/Rule
72a4888 -2 -2
Description: Recursive function which returns the last character position of 'character' in 'str', otherwise returns the                âââââ'pos' if not found.çä çäâââââParameters: 'str' = string, 'character' = string character, 'pos'=last positionçä çäModification Log:çä10/31/2007 CSC Initial Calculation/Rule
72a4908 -2 -2
Description: Returns True (i.e. 1) if s is equal to one of the elements of the vector.çä çäModification Log:çä10/31/2007 CSC Initial Calculation/Rule
72a4988 -2 -2
Description:   This function searches through a multi dimensional vector and returns the indexçäâââââ   for the every dimension this means that a search in a 2 dimensional vector will returnçäâââââ   a vector with 2 elements representing the index for each dimension. The order of the çäâââââ   indexes are the highest first and the lowest lastçäâââââ   example:  f_v_search(v_("a";"b";v_("a";"c";"b");"d";"e"); "c") = (1!2)çäâââââ   meaning that result is in the element 2 in the first vector and in element 1 within the çäâââââ   sub vectorçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4a08 -2 -2
Description: Searches a vectorçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4a88 -2 -2
Description:  Converts a delimited string into a vector of the delimited values.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4b08 -2 -2
Description:  Converts a delimited string into a vector of the delimited values.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4b88 -2 -2
Description:  Converts a delimited string into a vector of the delimited values.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4b88 0 2

72a4c08 -2 -2
Description:  Function to be able to run test cases on a function that converts a delimited string into a vector çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001çä10/31/2007 CSC Initial Calculation/Rule
72a4d08 -2 -2
Description: Sums between certain elements in a vectorçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a4d88 -2 -2
Description: Inversts the order of the elements in a vectorçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a4e08 -2 -2
Description: Cap the elements in a vector at elementMinçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a4e88 -2 -2
Description: Floor the elements in a vector at elementMaxçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a4f08 -2 -2
Description: Rounds each element usevector to d deciaml places using GEN Round. Returns the rounded vector.çä çäModification Log:çä11/16/2009 - PAC009 - JL - Initial Function
72a4f88 -2 -2
Description : Creates a blank solve parms vectorçä çäModification Log :çä10/07/2010 pA Regression CMC initial function
72a5188 -2 -2
Description:  sorts the use vector on an ascending basis based on the first element in the vectors to be sorted.çä çäModification Log:çä9/22/2011 wma-JâCMC Initial Function
72a5208 -2 -2
Description:  sorts the use vector on an descending basis based on the first element in the vectors to be sorted.çä çäModification Log:çä9/22/2011 wma-JâCMC Initial Function
72a5288 -2 -2
Description:  Reads through a given vector (useVector) and returns a vector of unique elements from the specified positionçä çäModification Log:çä04/17/2012 wma-JâCMC Initial Function
72a5308 -2 -2
Description: Sums the elements in the stipulated position from the beginning of the vector to the ending element number providedçä çäModification Log:çä04/17/2012 wmA-J CMC  Initial Calculation
72a5408 -2 -2
Description:  Removes elements from a vector based on the provided data and the position of the data in the vector.çä çäModification Log:çä04/17/2012 wma-JâCMC Initial Function
72a7af8 -2 -2
Description:  Finds a specific string in a vectorçä çäModification Log:çä04/17/2012 wma-JâCMC Initial Function
72a7bf8 -2 -2
Description: Converts the date to format YYYYMMDD.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Ruleçä çä çä
72a7cf8 -2 -2
Description:  Retrieve Version Informationçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Ruleçä
72a7d78 -2 -2
Description:  Retrieve Version Informationçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Ruleçä
72a7df8 -2 -2
Description:  Cut out necessary Info from Repository table entryçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a7e78 -2 -2
Description:  Cut out necessary Info from Repository table entryçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a7ef8 -2 -2
Description:  Cut out necessary Info from Repository table entryçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a7f78 -2 -2
Description:  Retrieve Version Informationçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a7ff8 -2 -2
Description:  Returns Model Manger version informationçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a8078 -2 -2
Description:  Returns repository informationçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a80f8 -2 -2
Description: Returns CHR(10) which represents a new line control characterçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a8178 -2 -2
Description: Returns CHR(10) which represents a new line control characterçä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a8278 -2 -2
Description: Return the factor for the future value with interest compounded for n periods.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a82f8 -2 -2
Description: Return the number of months represented by a payment mode.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a8378 -2 -2
Description: Return the number of months represented by a payment mode.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a83f8 -2 -2
Description:  Returns an interpolated number between value1 and value2.çä çäModification Log:çä03/05/2008 CSC Illustrations ILLUS001  Modified function for performanceçä10/31/2007 CSC Initial Calculation/Rule
72a8478 -2 -2
Description: Ordered Release Amountçä çäModification Log:çä04/20/2012 wma-J CMC commented out specified amount option as it has not been testedçä04/16/2012 wmA-J CMC Added Specified amount optionçä08/17/2009 - PAC009 - JL - Initial Calculation
72a84f8 -2 -2
Description: FIFO Release Amountçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a8578 -2 -2
Description: Pro-Rata Release Amountçä çäModification Log:çä08/17/2009 - PAC009 - JL - Initial Calculation
72a85f8 -2 -2
Description: Converts codes to string for release typesçä çäModification Log:çä04/18/2012 wmA-J CMC Initial Calculation
72a86f8 -2 -2
Description: Release Amount allocated to a spcified fund first and then prorata.çä çäModification Log:çä04/18/2012 wmA-J  CMC  Initial Calc
72a8778 -2 -2
Description:  Returns true if a value is not blank or zeroçä çäModification Log:çä12/17/2009 nbA Integration CMC Added Function
72a8878 -2 -2
Description: IRR Calculation. Checks if IRR is Calculable, if so uses Internal Solve, checks and if needed uses Coded Solve. If all fails, returns -100.çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72a88f8 -2 -2
Description: Returns True if IRR is calculable; else returns False.çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72a8978 -2 -2
Description: Returns True if the IRR solve was successful. Else returns False.çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72a89f8 -2 -2
Description: Internal IRR Solveçä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72ac098 -2 -2
Description: Coded IRR Solve. Used if Internal Solve fails.çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72ac118 -2 -2
Description: Recursive IRR Solveçä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72ac198 -2 -2
Description: Subsequent IRR Guess. çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72ac218 -2 -2
Description: IRR Target value (Targets 0). çä çäModification Log:çä09/15/2010 PAC018 JL Initial Calculation
72ac298 -2 -2
Description: Non-Periodic IRR Calculation. Checks if IRR is Calculable, if so uses Internal Solve function (Newton Raphson), checks and if needed uses Coded Solve. If all fails, returns -100.çä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac318 -2 -2
Description: Internal Solve function NP IRR Solveçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac398 -2 -2
Description: NP IRR Low Boundçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac418 -2 -2
Description:  This function is called when a new  Internal Rate of Return must be guessed at - it resets the lower bound if needed.çä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac498 -2 -2
Description: NP IRR High Boundçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac518 -2 -2
Description:  This function is called when a new  Internal Rate of Return must be guessed at - it resets the high bound if needed.çä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac598 -2 -2
Description: Coded NP IRR Solve. Used if Internal Solve fails.çä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac618 -2 -2
Description: Recursive NP IRR Solveçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac698 -2 -2
Description: Returns TRUE if the IRR Guess results in a solve value within tolerance; else returns FALSEçäNote:  solveVector = vector of parms passed to standard internal function and consists of cash flow vector, investment return amount, invest return date, initial guess, tolerance amount, round decimalsçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac718 -2 -2
Description: Subsequent IRR Guess. çä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac798 -2 -2
Description: FV of all cash flows, at currGuess rate of returnçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac818 -2 -2
Description: FV of specific cash flow, at currGuess rate of returnçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac898 -2 -2
Description: Derivative of FV of all cash flows, at currGuess rate of returnçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ac918 -2 -2
Description: Derivative of FV of specific cash flow, at currGuess rate of returnçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72aca18 -2 -2
Description: Returns the CashFlowVector from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72aca98 -2 -2
Description: Returns the InvestmentReturnAmount from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72acb18 -2 -2
Description: Returns the InvestmentReturnPeriod from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72acb98 -2 -2
Description: Returns the InitialGuess from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72acc18 -2 -2
Description: Returns the InvestmentReturnDate from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72acc98 -2 -2
Description: Returns the ToleranceAmount from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72acd18 -2 -2
Description: Returns the RoundDecimals from the solveVectorçä çäModification Log:çä10/05/2010 PAC018 JL Initial Calculation
72ace18 -2 -2
Description:  Allocation Functionçä çäModification Log:çä05/16/2013 wmaJ 1301 CMC Updated to sort PROP method so that last fund gets any excess.çä9/22/2011 wma-JâCMC Initial Function
72ace98 -2 -2
Description:  Allocates based on amountsçä çäModification Log:çä05/26/2014 wmA-J 1501 Release 1 Sprint 2 JvdM Added Allocated rounding function.çä09/27/2012 wmA-J Release 2 Sprint 4 CMC Added logic to return remaining net deposit when amount is fully being surrendered.  This avoids rounding errors from discounting.çä04/20/2012 wma-J CMC fixed the date in the vectorçä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä04/18/2012 wma-JâCMC added additional return elements and discounted amount for wmaJçä9/22/2011 wma-JâCMC Initial Function
72acf18 -2 -2
Description:  determines the remaining amount to be allocated for amount allocationsçä çäModification Log:çä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä9/22/2011 wma-JâCMC Initial Function
72acf98 -2 -2
Description:  Allocates based on percentagesçä çäModification Log:çä09/27/2012 wmA-J Release 2 Sprint 4 CMC Added logic to return remaining net deposit when amount is fully being surrendered.  This avoids rounding errors from discounting.çä04/20/2012 wma-J CMC fixed the date in the vectorçä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä04/18/2012 wma-JâCMC added additional return elements and discounted amount for wmaJçä9/22/2011 wma-JâCMC Initial Function
72b0728 -2 -2
Description:  determines the remaining amount to be allocated for percentage allocationsçä çäModification Log:çä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä9/22/2011 wma-JâCMC Initial Function
72b07a8 -2 -2
Description:  Allocates amount proportionatelyçä çäModification Log:çä12/03/2014 wmA-J 1501 Sprint 9 JvdM Removed double rounding.çä07/01/2013 wmA-J 1401 Release 1 Sprint 1 JvdM Added rounding around division.çä05/16/2013 wmaJ 1301 CMC Updated to sort PROP method so that last fund gets any excess.çä09/27/2012 wmA-J Release 2 Sprint 4 CMC Added logic to return remaining net deposit when amount is fully being surrendered.  This avoids rounding errors from discounting.çä04/20/2012 wma-J CMC fixed the date in the vectorçä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä04/18/2012 wma-JâCMC added additional return elements and discounted amount for wmaJçä9/22/2011 wma-JâCMC Initial Functionçä
6980888b -2 -2
Description:  determines the remaining amount to be allocated for percentage allocationsçä çäModification Log:çä05/16/2013 wmaJ 1301 CMC Initial Calc
c56aa81 -2 -2
Description: Rounding for Fixed or Equity annuities based on fundcode.çä çäModification Log:çä05/26/2014 wmA-J 1501 Release 1 Sprint 2 JvdM Initial Calc
825bab7 -2 -2
Description:âFunction to determine the fundcode from the particular usevector.çä çäModification Log:çä05/26/2014 wmA-J 1501 Release 1 Sprint 2 JvdM Initial Calc
72b08a8 -2 -2
Description:  Readability function to pull sort factor from the useVectorçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b0928 -2 -2
Description:  converts sort item to a date in date format or leave alone if not a date sorting optionçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b09a8 -2 -2
Description:  Readability function to pull fund code from the useVectorçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b0a28 -2 -2
Description:  Readability function to pull flow id from the useVectorçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b0aa8 -2 -2
Description:  Readability function to pull discount factor from the useVectorçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b0b28 -2 -2
Description:  Readability function to pull remaining net deposit from the useVectorçä çäModification Log:çä09/27/2012 wmA-JâRelease 2 Sprint 4 CMC Initial Function
72b0ba8 -2 -2
Description:  Readability function to pull allocation basis from the useVectorçä çäModification Log:çä04/20/2012 wma-JâCMC Initial Function
72b0c28 -2 -2
Description:  Returns vector of allocated amountsçä çäModification Log:çä04/18/2012 wma-JâCMC Initial Calc
72b0ca8 -2 -2
Description:  Builds vector of allocated amountsçä çäModification Log:çä05/26/2014 wmA-J 1501 Release 1 Sprint 2 JvdM Added allocated rounding.çä04/18/2012 wma-JâCMC Initial Calc
72b0d28 -2 -2
Description:  Inserts data from useVector into finalVectorçä çäModification Log:çä04/18/2012 wma-JâCMC Initial Function
72b0da8 -2 -2
Description:  Amount of the withdrawal allocated to a specific fundçä çäModification Log:çä04/18/2012 wma-JâCMC Initial Calc
72b0e28 -2 -2
Description:  Total Policy Accumulated Value from vectorçä çäModification Log:çä04/18/2012 wma-JâCMC Initial Calc
72b0ea8 -2 -2
Description:  Determines accumulation value for stipulated fundçä çäModification Log:çä04/18/2012 wma-JâCMC Initial Calc
72b0fa8 -2 -2
Description:  returns a delimited text string to be provided back to wmA-J to populate flow.çä çäModification Log:çä04/17/2012 wma-JâCMC Initial Function
72b1028 -2 -2
Description:  removes the amount and the flow ID from the vector and creates a delimited stringçä çäModification Log:çä05/17/2012 wma-J CMC changed to check for a default flow id of a text value and ignore putting it in the stringçä05/09/2012 wma-J  rm  changed internal separator to ";" that enables generic parsing in REPçä04/20/2012 wma-J CMC updated to use readabiltiy functionsçä04/18/2012 wma-JâCMC Added fund code to the returnçä04/17/2012 wma-JâCMC Initial Function
72b10a8 -2 -2
Description: Conversion of vector to string.  delimiter1 uses within each vector element.  deliminter 2 used between each vector.  çä çäModification Log:çä10/30/2012 wma-J  rm - Initial Function
72b1128 -2 -2
Description:  summarizes the allocated amount by fundçä çäModification Log:çä05/17/2012 wma-JâCMC Initial Function
72b11a8 -2 -2
Description:  creates a vector of fund names from the allocated amount vector.çä çäModification Log:çä05/17/2012 wma-JâCMC Initial Function
7f639b96 -2 -2
Description: Tests to see if value 1 is "N/A". If TRUE, return value2, ELSE return value1 (Excel IFERROR).çä çäModification Log:çä02/23/2015 - PAC031 MEC Avoidance - JL - Initial Calculation
72b1228 -2 -2
Description:  test vector for initial testing of the allocation function...(REMOVE before delivery)çä çäModification Log:çä9/22/2011 wma-JâCMC Initial Function
72b14a8 -2 -2
Named T_RepositoryInformation as this the is how Model Manager is expecting the name.
;Offset=00000000
